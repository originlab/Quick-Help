<h1 class="firstHeading">3.7.5.16 File</h1><p class='urlname' style='display: none'>File-obj</p>
<p>The <b>file</b> object is used for reading and writing any file so that your data can be brought directly into an Origin worksheet. Please <b>note</b> that before Origin 7, the FUM (File Utility Module) is used for such functionality.
</p>
<h2><a name="Properties:Layer_propertie"></a><span class="mw-headline"><font color="chocolate">Properties:</font><span class="OIndex" style="display:none">Layer propertie</span></span></h2>
<p>The <b>file</b> object properties include three basic categories, file management properties, binary data properties, ASCII data properties, and error properties.
</p>
<ul><li> <b>File Management Properties</b></li></ul>
<p>File management properties refer to file management parameters.  
</p>
<table class="simple">
<tr>
<th width="110">Property
</th>
<th width="70">Access
</th>
<th width="470">Description
</th></tr>
<tr>
<td><b>file.filename$</b>
</td>
<td> read/write, string
</td>
<td> Name of the last opened file. Note that the last opened file is not necessarily the name of the active file. If you provide a file name, then <b>file.open()</b> method without argument will open this file for read-only.
</td></tr>
<tr>
<td><b>file.mode</b>
</td>
<td> read/write, numeric
</td>
<td> This indicates what mode the file was opened in when using the <b>file.open()</b> method.  The possible values are 0 for read-only (default), 1 for write-only, and 2 for read-write.
</td></tr>
<tr>
<td><b>file.hFile</b>
</td>
<td> read, numeric
</td>
<td> This is the handle of the active opened file.
</td></tr>
<tr>
<td><b>file.name$</b>
</td>
<td> read/write, string
</td>
<td> The same as <b>file.filename$</b>.
</td></tr>
<tr>
<td><b>file.openMode</b>
</td>
<td> read/write, numeric
</td>
<td> The same as <b>file.mode</b>.
</td></tr>
<tr>
<td><b>file.Version</b>
</td>
<td> read, numeric
</td>
<td> OBSOLETE. Was the version of the DLL.
</td></tr>
<tr>
<td><b>file.OrgVer</b>
</td>
<td> read, numeric
</td>
<td> OBSOLETE. Was the minimum Origin version required.
</td></tr></table>
<p><br />
</p>
<ul><li> <b>Binary Data Properties</b></li></ul>
<p>Binary data properties control binary data processing. They are typically set before reading or writing to a binary file.
</p>
<table class="simple">
<tr>
<th width="110">Property
</th>
<th width="70">Access
</th>
<th width="470">Description
</th></tr>
<tr>
<td><b>file.nByte</b>
</td>
<td> read/write, numeric
</td>
<td> The same as <b>file.nBytes</b>.
</td></tr>
<tr>
<td><b>file.nBytes</b>
</td>
<td> read/write, numeric
</td>
<td> This property designates how many bytes there are per data value. Depending upon the command and type of data, the values could be 1 (default), 2, 3, 4, 8, or 10. Note that 3 has limited support and 10 is no longer supported.
</td></tr>
<tr>
<td><b>file.byteOrder</b>
</td>
<td> read/write, numeric
</td>
<td> This property indicates what order two and four byte data is read in (or written out) if read from a file (or written to a file). Values could be 0 (low byte first, default), or 2 (high byte first).
</td></tr>
<tr>
<td><b>file.signed</b>
</td>
<td> read/write, numeric
</td>
<td> This property indicates if read data should be interpreted as signed or unsigned. Values could be 0 (unsigned, default), or 1 (signed).
</td></tr>
<tr>
<td><b>file.skip</b>
</td>
<td> read/write, numeric
</td>
<td> This property designates how many bytes in the file should be skipped after each data point is read (or written) when using the methods <b>file.Aread()</b>, <b>file.ReadBinRow()</b>, or <b>file.Awrite()</b>.
</td></tr></table>
<ul><li> <b>ASCII Data Properties</b></li></ul>
<p>ASCII data properties control ASCII data processing. They are typically set before reading or writing to an ASCII file.
</p>
<table class="simple">
<tr>
<th width="110">Property
</th>
<th width="70">Access
</th>
<th width="470">Description
</th></tr>
<tr>
<td><b>file.nLineMode</b>
</td>
<td> read/write, numeric
</td>
<td> This designates the ASCII line ending mode used.  Values could be 0 (Carriage Return and Line Feed - Windows &amp; DOS, default), 1 (Line Feed - Unix, Linux, Mac OS X) or 2 (Carriage Return - Apple up to OS-9).
</td></tr>
<tr>
<td><b>file.nLinesMode</b>
</td>
<td> The same as <b>file.nLineMode</b>.
</td></tr>
<tr>
<td><b>file.listSep</b>
</td>
<td> read/write, numeric
</td>
<td> This indicates the numeric value of the current token separator (sometimes called list separator, or delimiter) to be used for ASCII import/export. The default is "," which corresponds to <b>file.listSep = <i>44</i></b>.  The list separator may also be set using the ASCII method <b>file.listSep(character)</b> - e.g. file.listSep(Z). This method allows the delimiter to be set without knowing the numeric value of the character.
</td></tr></table>
<p><br />
</p>
<ul><li> <b>Error Properties</b></li></ul>
<p>There are four error categories when using the <b>file</b> object, including argument format errors, general Origin DLL errors, <b>file</b> object specific errors, and Microsoft DOS file access errors. The first three types are reported in the property <b>file.error</b>, and the last is reported in <b>file.sysErr</b>.
</p>
<table class="simple">
<tr>
<th width="110">Property
</th>
<th width="70">Access
</th>
<th width="470">Description
</th></tr>
<tr>
<td><b>file.error</b>
</td>
<td> read, numeric
</td>
<td> This is used to report argument format errors, general Origin DLL errors, and <b>file</b> object specific errors. See the details in the tables below.
</td></tr>
<tr>
<td><b>file.sysErr</b>
</td>
<td> read, numeric
</td>
<td> System error number.
</td></tr></table>
<ol>
<li>Argument Format Errors</li>
<p>Any method that receives arguments will check that the arguments are of the correct format. If there is an error in any argument format, format bit 7 (ARG_FORMAT) of <b>file.error</b> will be set. In addition, each argument field that is found to be in error will have its associated bit set. For example, if the first argument were bad or missing, the error code would be 128 (ARG_FORMAT) plus 1 (1ST_ARGUMENT), or 129. 
</p>
<table class="simple">
<tr>
<th>Constant
</th>
<th>Error Number
</th>
<th>Bit
</th></tr>
<tr>
<td> 1ST_ARGUMENT
</td>
<td> 1
</td>
<td> bit 0
</td></tr>
<tr>
<td> 2ND_ARGUMENT
</td>
<td> 2
</td>
<td> bit 1
</td></tr>
<tr>
<td> 3RD_ARGUMENT
</td>
<td> 4
</td>
<td> bit 2
</td></tr>
<tr>
<td> 4TH_ARGUMENT
</td>
<td> 8
</td>
<td> bit 3
</td></tr>
<tr>
<td> ARGUMENT_PASSED_4TH
</td>
<td> 16
</td>
<td> bit 4
</td></tr>
<tr>
<td> ILLEGAL_ARGUMENT_VALUE
</td>
<td> 64
</td>
<td> bit 6; format bit 7 NOT set
</td></tr>
<tr>
<td> ARG_FORMAT
</td>
<td> 128
</td>
<td> bit 7
</td></tr></table>
<li>General Origin DLL Errors</li>
<table class="simple">
<tr>
<th>Constant
</th>
<th>Meaning
</th>
<th>Value
</th></tr>
<tr>
<td> DATASET_NOT_FOUND
</td>
<td> No dataset found
</td>
<td> 1
</td></tr>
<tr>
<td> WORKSHEET_NOT_FOUND
</td>
<td> No worksheet found
</td>
<td> 2
</td></tr>
<tr>
<td> ARGUMENT_OUT_OF_RANGE
</td>
<td> Argument list is out of range
</td>
<td> 3
</td></tr>
<tr>
<td> MICS_LOW_LEVEL_ROUTINE_FAILED
</td>
<td> Low level routine failed
</td>
<td> 4
</td></tr>
<tr>
<td> OUT_OF_MEMORY
</td>
<td> Not enough memory
</td>
<td> 5
</td></tr>
<tr>
<td> ERROR_ON_ORIGIN_CALL
</td>
<td> Error on Origin call
</td>
<td> 6
</td></tr></table>
<li>File Object Specific Errors</li>
<table class="simple">
<tr>
<th>Constant
</th>
<th>Meaning
</th>
<th>Value
</th></tr>
<tr>
<td> HFILE
</td>
<td> File handler error
</td>
<td> 1024
</td></tr>
<tr>
<td> FILE_CREATION
</td>
<td> File creation error
</td>
<td> 1025
</td></tr>
<tr>
<td> OPEN_FILE
</td>
<td> File open error
</td>
<td> 1026
</td></tr>
<tr>
<td> WRITE_FILE
</td>
<td> File writing error
</td>
<td> 1027
</td></tr>
<tr>
<td> GENERAL_FILE
</td>
<td> General file operation error
</td>
<td> 1028
</td></tr>
<tr>
<td> READ_FILE
</td>
<td> File reading error
</td>
<td> 1029
</td></tr></table>
<li>Microsoft DOS File Access Errors</li>
<p><b>File.sysErr</b> gives you access to Microsoft DOS file access errors. Refer to the following reference list for an explanation of each system error.  
</p>
<table class="simple">
<tr>
<th>Constant
</th>
<th>Meaning
</th>
<th>Value
</th></tr>
<tr>
<td> ENOENT
</td>
<td> No such file or folder
</td>
<td> 2
</td></tr>
<tr>
<td> E2BIG
</td>
<td> Argument list is too long
</td>
<td> 7
</td></tr>
<tr>
<td> ENOEXEC
</td>
<td> Exec error format
</td>
<td> 8
</td></tr>
<tr>
<td> EBADF
</td>
<td> Bad file number
</td>
<td> 9
</td></tr>
<tr>
<td> ENOMEM
</td>
<td> Not enough memory
</td>
<td> 12
</td></tr>
<tr>
<td> EACCES
</td>
<td> Permission denied
</td>
<td> 13
</td></tr>
<tr>
<td> EEXIST
</td>
<td> File exists
</td>
<td> 17
</td></tr>
<tr>
<td> EXDEV
</td>
<td> Cross-device link
</td>
<td> 18
</td></tr>
<tr>
<td> EINVAL
</td>
<td> Invalid argument
</td>
<td> 22
</td></tr>
<tr>
<td> EMFILE
</td>
<td> Too many open files
</td>
<td> 24
</td></tr>
<tr>
<td> ENOSPC
</td>
<td> No space left on device
</td>
<td> 28
</td></tr>
<tr>
<td> EDOM
</td>
<td> Math error
</td>
<td> 33
</td></tr>
<tr>
<td> ERANGE
</td>
<td> Result is too large
</td>
<td> 34
</td></tr>
<tr>
<td> EDEADLOCK
</td>
<td> Resource deadlock would occur
</td>
<td> 36
</td></tr></table>
</ol>
<h2><a name="Methods:"></a><span class="mw-headline"><font color="chocolate">Methods:</font></span></h2>
<p>There are three basic categories of methods in <b>file</b> object, general file management methods, binary file methods, and ASCII file methods.
</p>
<ul><li> <b>General File Management Methods</b></li></ul>
<p>General file management methods include all non-data actions. For example, opening and closing files, and getting or setting the file pointer, are general file management methods.
</p>
<table class="simple">
<tr>
<th width="180">Method
</th>
<th> Description
</th></tr>
<tr>
<td><b>file.close([<i>hFile</i>])</b>
</td>
<td> Close the opened file. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> 0: successful</li>
<li> -1: failed</li>
<li> --: an invalid <i>hFile</i> is specified</li></ul>
</td></tr>
<tr>
<td><b>file.closeAll()</b>
</td>
<td> Same as <b>file.closeAllFiles()</b>.
</td></tr>
<tr>
<td><b>file.closeAllFiles()</b>
</td>
<td> Close all opened files.
<p>Return value:
</p>
<ul><li> 0: successful</li>
<li> -1: failed</li></ul>
</td></tr>
<tr>
<td><b>file.delete(<i>filename$</i>)</b>
</td>
<td> Delete the specified file from disk.
<p>Return value:
</p>
<ul><li> 1: successful</li>
<li> 0: error occurred</li>
<li> --: the specified file does not exist</li></ul>
</td></tr>
<tr>
<td><b>file.exist(<i>filename$</i>)</b>
</td>
<td> Same as <b>file.exists()</b>.
</td></tr>
<tr>
<td><b>file.exists(<i>filename$</i>)</b>
</td>
<td> See if the specified file exists, the same as <b>file.exist()</b>.
<p>Return value:
</p>
<ul><li> 1: file exists</li>
<li> 0: not exist</li></ul>
</td></tr>
<tr>
<td><b>file.fastForward([<i>hFile</i>])</b>
</td>
<td> Same as <b>file.toEnd()</b>.
</td></tr>
<tr>
<td><b>file.fForward([<i>hFile</i>])</b>
</td>
<td> Same as <b>file.toEnd()</b>.
</td></tr>
<tr>
<td><b>file.getPos([<i>hFile</i>])</b>
</td>
<td> Get the current position of the file pointer relative to the beginning of the file in bytes.  <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the position of the file pointer if successful</li>
<li> -1 and set <b>file.error</b> property if failed</li></ul>
</td></tr>
<tr>
<td><b>file.listAll()</b>
</td>
<td> Same as <b>file.listAllFiles()</b>.
</td></tr>
<tr>
<td><b>file.listAllFiles()</b>
</td>
<td> List all opened files.
<p>Return value:
</p>
<ul><li> 1: if there are files opened, and list them</li>
<li> 0: if there are no files opened</li></ul>
</td></tr>
<tr>
<td><b>file.open(<i>filename$</i>[<i>, mode</i>])</b>
</td>
<td> Open the specified file. The <i>mode</i> may be set to 0 (read-only), 1 (write-only), or 2 (read and write). When no <i>mode</i> is specified the default is the value of the property <b>file.mode</b>. The <b>file.mode</b> defaults to read only if not set by the user. If the designated file does not exist, it is created, opened, and will allow you to read or write to it.
<p>Return value:
</p>
<ul><li> the file handle if successful</li>
<li> -1 if failed</li></ul>
</td></tr>
<tr>
<td><b>file.remove(<i>filename$</i>)</b>
</td>
<td> Same as <b>file.delete()</b>.
</td></tr>
<tr>
<td><b>file.reset()</b>
</td>
<td> Reset all the file object properties to their default values.
<p>Return value:
</p>
<ul><li> 0: successful</li>
<li> -1: failed</li></ul>
</td></tr>
<tr>
<td><b>file.rewind([<i>hFile</i>])</b>
</td>
<td> Reset the file pointer to the beginning of the file. Defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> 0: successfully reset</li>
<li> -1 and set <b>file.error</b> property: error occurred</li></ul>
</td></tr>
<tr>
<td><b>file.setPos(<i>pos</i>[<i>,hFile</i>])</b>
</td>
<td> Set the file pointer to the position specified by the user, counting in bytes starting at 0. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the new position of the file pointer if successful</li>
<li> -1 and set <b>file.error</b> if failed</li></ul>
</td></tr>
<tr>
<td><b>file.size([<i>hFile</i>])</b>
</td>
<td> Get the size of a file. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the size of the file in bytes</li>
<li> -1 and set <b>file.sysErr</b> if failed</li></ul>
</td></tr>
<tr>
<td><b>file.switchMode(<i>nMode</i>)</b>
</td>
<td> Change the mode of the active opened file. <i>nMode</i> can be 0 for read-only (default), 1 for write-only, and 2 for read-write.
</td></tr>
<tr>
<td><b>file.toBegin([<i>hFile</i>])</b>
</td>
<td> Same as <b>file.rewind()</b>.
</td></tr>
<tr>
<td><b>file.toBeginning([<i>hFile</i>])</b>
</td>
<td> Same as <b>file.rewind()</b>.
</td></tr>
<tr>
<td><b>file.toEnd([<i>hFile</i>])</b>
</td>
<td> Set the file pointer to the end of the file. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user. This is useful if you want to append data to the end of a file of unknown length.
<p>Return value:
</p>
<ul><li> the number of bytes in the file</li>
<li> -1 and set <b>file.error</b> if failed</li></ul>
</td></tr>
<tr>
<td><b>file.toStart([<i>hFile</i>])</b>
</td>
<td> Same as <b>file.rewind()</b>.
</td></tr>
<tr>
<td><b>file.wksBlock(<i>wksName$, colBegin, colEnd, rowBegin, rowEnd</i>)</b>
</td>
<td> Read numeric data from the currently opened file into the worksheet, <i>wksname</i>, beginning at <i>colBegin</i> and ending at <i>colEnd</i>.  If non-numeric data is encountered, the entire line is placed in <b>%Z</b> and this operation terminates.
<p>Specify <i>rowBegin</i> and <i>rowEnd</i> arguments, or specify 0 for <i>rowEnd</i> to read the block until EOF (end of file).
</p><p>Please note that, <i>colBegin</i>, <i>colEnd</i>, <i>rowBegin</i> and <i>rowEnd</i> mean the column and row in the file, but not the column and row in the worksheet.
</p>
</td></tr></table>
<ul><li> <b>Binary File Methods</b></li></ul>
<p>Binary file methods include the reading and writing of binary data between files and worksheets or LabTalk variables.
</p>
<table class="simple">
<tr>
<th width="180">Method
</th>
<th> Description
</th></tr>
<tr>
<td><b>file.ARead(<i>dataset$, start, end, binType</i>[<i>, hFile</i>])</b>
</td>
<td> Read an array of data from a file and write to a worksheet. <i>dataset$</i> is the name of the specified column of the worksheet, <i>WksName_ColName</i>. <i>start</i> and <i>end</i> are the starting and ending rows within the column. Column numbering starts at one. <i>binType</i> designates what type of data is being read: 0 (integer), 1 (float), 2 (BCD). When <i>binType</i> is 0 (int), the property <b>file.signed</b> determines if the values are signed, and the property <b>file.byteOrder</b> determines the byte order. The data will be stored as double point values in the worksheet. The number of bytes per data point is taken from the property <b>file.nBytes</b>. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the number of data points read, (<i>end</i> - <i>start</i>) + 1</li>
<li> a null value (--) if failed</li></ul>
</td></tr>
<tr>
<td><b>file.arrayRead(<i>dataset$, start, end, binType</i>[<i>, hFile</i>])</b>
</td>
<td> Same as <b>file.ARead()</b>.
</td></tr>
<tr>
<td><b>file.arrayWrite(<i>dataset$, start, end, binType</i>[<i>, hFile</i>])</b>
</td>
<td> Same as <b>file.AWrite()</b>.
</td></tr>
<tr>
<td><b>file.AWrite(<i>dataset$, start, end, binType</i>[<i>, hFile</i>])</b>
</td>
<td> Read an array of data from a worksheet and write to a file. <i>dataset$</i> is the name of the specified column of the worksheet, <i>WksName_ColName</i>. <i>start</i> and <i>end</i> are the starting and ending rows within the column. <i>binType</i> designates what type of data is being written: 0 (integer), 1 (float), 2 (BCD). Please note that BCD is not supported for <b>file.AWrite()</b>.  When <i>binType</i> is 0 (int), the property <b>file.signed</b> determines if the values are signed, and the property <b>file.byteOrder</b> determines the byte order. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user. The number of bytes per data point is taken from the property <b>file.nBytes</b>. 3 byte data is not supported.
<p>Return value:
</p>
<ul><li> the number of data points written, (<i>end</i> - <i>start</i>) + 1</li>
<li> a null value (--) if failed</li></ul>
</td></tr>
<tr>
<td><b>file.doubleRead([<i>hFile</i>])</b>
</td>
<td> Same as <b>file.DRead()</b>.
</td></tr>
<tr>
<td><b>file.DRead([<i>hFile</i>])</b>
</td>
<td> Read a double point value from a file. The value will consist of 8 bytes. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the double point value read</li>
<li> <b>file.error</b> and <b>file.sysErr</b> will be set if there is an error</li></ul>
</td></tr>
<tr>
<td><b>file.doubleWrite(<i>value</i>[<i>, hFile</i>])</b>
</td>
<td> Same as <b>file.DWrite()</b>.
</td></tr>
<tr>
<td><b>file.DWrite(<i>value</i>[<i>, hFile</i>])</b>
</td>
<td> Write a double point value to a file. <i>value</i> can be a number or a variable name. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the number of bytes of the value, 8</li>
<li> a null value (--) and set <b>file.error</b> and <b>file.sysErr</b> if failed</li></ul>
</td></tr>
<tr>
<td><b>file.floatRead([<i>hFile</i>])</b>
</td>
<td> Same as <b>file.FRead()</b>.
</td></tr>
<tr>
<td><b>file.FRead([<i>hFile</i>])</b>
</td>
<td> Read a float value from a file. The value will consist of 4 bytes. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the float value read</li>
<li> <b>file.error</b> and <b>file.sysErr</b> will be set if there is an error</li></ul>
</td></tr>
<tr>
<td><b>file.floattrite(<i>value</i>[<i>, hFile</i>])</b>
</td>
<td> Same as <b>file.FWrite()</b>.
</td></tr>
<tr>
<td><b>file.FWrite(<i>value</i>[<i>, hFile</i>])</b>
</td>
<td> Write a float value to a file. The value can be a number or a variable name. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the number of bytes of the value, 4</li>
<li> a null value (--) and set <b>file.sysErr</b> if failed</li></ul>
</td></tr>
<tr>
<td><b>file.integerRead([<i>nBytes</i>[<i>, hFile</i>]])</b>
</td>
<td> Same as <b>file.Read()</b>.
</td></tr>
<tr>
<td><b>file.integerWrite(<i>value</i>[<i>, nBytes</i>[<i>, hFile</i>]])</b>
</td>
<td> Same as <b>file.Write()</b>.
</td></tr>
<tr>
<td><b>file.intRead([<i>nBytes</i>[<i>, hFile</i>]])</b>
</td>
<td> Same as <b>file.Read()</b>.
</td></tr>
<tr>
<td><b>file.intWrite(<i>value</i>[<i>, nBytes</i>[<i>, hFile</i>]])</b>
</td>
<td> Same as <b>file.Write()</b>.
</td></tr>
<tr>
<td><b>file.lDoubleRead([<i>hFile</i>])</b>
</td>
<td> Alias for <b>file.LDRead()</b> (Obsolete).
</td></tr>
<tr>
<td><b>file.lDoubleWrite(<i>value</i>[<i>, hFile</i>])</b>
</td>
<td> Same as <b>file.LDWrite()</b> (Obsolete).
</td></tr>
<tr>
<td><b>file.LDRead([<i>hFile</i>])</b>
</td>
<td> Read a long double (10 byte) value from a file. This method is obsolete since Microsoft compilers now map long double to double.
</td></tr>
<tr>
<td><b>file.LDWrite(<i>value</i>[<i>, hFile</i>])</b>
</td>
<td> Write a value to a file as a long double (10 bytes). This method is obsolete since Microsoft compilers now map long double to double.
</td></tr>
<tr>
<td><b>file.longDoubleRead([<i>hFile</i>])</b>
</td>
<td> Same as <b>file.LDRead()</b> (Obsolete).
</td></tr>
<tr>
<td><b>file.longDoubleWrite(<i>value</i>[<i>, hFile</i>])</b>
</td>
<td> Alias for <b>file.LDWrite()</b> (Obsolete).
</td></tr>
<tr>
<td><b>file.Read([<i>nBytes</i>[<i>, hFile</i>]])</b>
</td>
<td> This reads an integer of <i>nBytes</i> from the file hFile. <i>nBytes</i> defaults to the number of bytes specified by the property <b>file.nBytes</b> if not set here. This will default to 1 if never set by the user. The byte order is controlled by the property <b>file.byteOrder</b>. This defaults to low byte first. Signed or unsigned is controlled by the property <b>file.signed</b>. The default is unsigned. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the integer read</li>
<li> 0 if no value</li></ul>
</td></tr>
<tr>
<td><b>file.ReadRowBin(<i>wksname$, nToken, binType</i>[<i>, hFile</i>])</b>
</td>
<td> Read an array of binary data from a file and write to a worksheet. <i>wksname$</i> is the name of the worksheet, e.g., Book1 (case-insensitive). <i>nToken</i> is the number of data points to be read. <i>binType</i> designates what type of data is being read: 0 (integer), 1 (float), or 2 (BCD). The number of bytes per data point is taken from the property <b>file.nBytes</b>. When <i>binType</i> is 0 (int), the property <b>file.signed</b> determines if the values are signed, and the property <b>file.byteOrder</b> determines the byte order. The data will be written to the worksheet as a row. The row will be appended to the last row with data in the worksheet. The first column will be the left-most column of the worksheet. The data will be stored to the worksheet as double floats. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the number of data points read</li>
<li> a null value (--) if failed</li></ul>
</td></tr>
<tr>
<td><b>file.Write(<i>value</i>[<i>, nBytes</i>[<i>, hFile</i>]])</b>
</td>
<td> Write an integer, <i>value</i>, to a file. The value can be either a number or a variable. <i>nBytes</i> defaults to 1. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the number of bytes of the value, <i>nBytes</i>  </li>
<li> a null value (--) if failed</li></ul>
</td></tr></table>
<ul><li> <b>ASCII File Methods</b></li></ul>
<p>ASCII file methods include the reading and writing of ASCII data between files and worksheets or LabTalk variables.
</p>
<table class="simple">
<tr>
<th width="180">Method
</th>
<th> Description
</th></tr>
<tr>
<td><b>file.Cread(<i>strVarLetter, nchar</i>[<i>, hFile</i>])</b>
</td>
<td> Read <i>nchar</i> characters from a file, and store in <i>strVarLetter</i>. <i>strVarLetter</i> is a specified letter (A-Z), e.g., <i>M</i>, then print the string by <i>%M = </i>. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the length of the string read</li>
<li> a null value (--) if failed</li></ul>
</td></tr>
<tr>
<td><b>file.LineRow(<i>wksname$</i>[<i>, hFile</i>])</b>
</td>
<td> Read an array of ASCII data from a file and write to a worksheet. <i>wksname$</i> is the name of the worksheet, e.g., Book1 (case-insensitive). Tokens in the file are separated by the character defined by <b>file.listSep()</b>. End of line strings (CR) in the file will terminate the read, as will the end of the file. The data to be read must be in ASCII format. The data will be written to the worksheet as a row. The row will be appended to the last row with data in the worksheet. The first column will be the left-most column of the worksheet. The data will be stored in the worksheet as double floats. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the number of tokens read if successful </li>
<li> a null value (--) if failed</li></ul>
</td></tr>
<tr>
<td><b>file.ListSep(<i>character</i>)</b>
</td>
<td> This method is one of two ways to set the list separator to be used in importing or exporting an ASCII file.
<p>This method actually sets the property <b>file.listSep</b>. Therefore, another way to set the separator is to manually set the <b>file.listSep</b> property to the numeric value of the ASCII code corresponding to the desired delimiter. However, the method is more user-friendly since it allows one to set the delimiter without knowing the numeric value of the character.
</p><p>Example:
file.listsep(z); // Sets list separator to 90, the ASCII value of lower case z.
</p><p>Return value is undefined.
</p>
</td></tr>
<tr>
<td><b>file.LRead(<i>strVarLetter</i>[<i>,hFile</i>])</b>
</td>
<td> Read a line (including line ending character) from a file, and use <i>strVarLetter</i> to store the string. <i>strVarLetter</i> is a specified letter (A-Z), e.g., <i>M</i>, then print the string by <i>%M = </i>.  <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the length of the line read</li>
<li> 0 if a blank line or end-of-file is reached </li>
<li> -1 if failed</li></ul>
</td></tr>
<tr>
<td><b>file.LWrite("<i>string</i>"[<i>, hFile</i>])</b>
</td>
<td> Write a line (string + line ending mode) to a file. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user. This function uses the <b>file.nLineMode</b> property as the line ending mode.
<p>Return value:
</p>
<ul><li> the length of the line written, including line ending mode</li>
<li> 65534 or a null value (--) if failed</li></ul>
</td></tr>
<tr>
<td><b>file.ReadArray(<i>dataset$, start, end</i>[<i>, hFile</i>])</b>
</td>
<td> Read an array of ASCII data from the file, convert to double float, and write to a worksheet. <i>dataset$</i> is the name of the specified column of the worksheet, e.g., data1_a (case-insensitive). <i>start</i> and <i>end</i> are the starting and ending positions within the column. The data to be read must be in ASCII format. The property <b>file.listSep</b> is used as the delimiter between ASCII data points. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the number of data points read, (<i>end</i> - <i>start</i>) + 1</li>
<li> a null value (--) if failed</li></ul>
</td></tr>
<tr>
<td><b>file.ReadRow(<i>wksname$, nToken</i>[<i>, hFile</i>])</b>
</td>
<td> Read an array of ASCII data from a file and write to the a worksheet as a row. <i>wksname$</i> is the name of the worksheet, e.g., Book1 (case-insensitive). <i>nToken</i> is the number of tokens to be read. Tokens in the file are separated by the character defined by <b>file.listSep()</b>. The data to be read must be in ASCII format and separated by the delimiter specified by the property <b>file.listSep</b>. The data will be written to the worksheet as a row. The row will be appended to the last row with data in the worksheet. The first column will be the left most column of the worksheet. The data will be stored to the worksheet as double floats. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the number of tokens read</li>
<li> a null value (--) if failed</li></ul>
</td></tr>
<tr>
<td> <b>file.readToken(<i>strVarLetter, nToken</i>[<i>, hFile</i>])</b>
</td>
<td> Read <i>nToken</i> tokens (including list separators) from a file, and store in <i>strVarLetter</i>. <i>strVarLetter</i> is a specified letter (A-Z), e.g., <i>M</i>, then print the string by <i>%M = </i>. The tokens must be in ASCII and separated by the list separator defined by the property <b>file.listSep</b>. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the length of the string read</li>
<li> a null value (--) if failed</li></ul>
</td></tr>
<tr>
<td><b>file.Tread(<i>strVarLetter, nLine</i>[<i>, hFile</i>])</b>
</td>
<td> Read <i>nLine</i> lines (including line ending mode) from a file, and store in <i>strVarLetter</i>. <i>strVarLetter</i> is a specified letter (A-Z), e.g., <i>M</i>, then print the string by <i>%M = </i>. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the length of the string read</li>
<li> a null value (--) if failed</li></ul>
</td></tr>
<tr>
<td><b>file.Twrite("<i>string</i>[<i>, hFile</i>])</b>
</td>
<td> Write a string to a file in the first line. If the first line contains string, the corresponding positions will be replace by the written string. <i>hFile</i> defaults to the file handle of the most recently used file if not specified by the user.
<p>Return value:
</p>
<ul><li> the length of the string, including the end of line characters</li>
<li> 65534 or a null value (--) if failed</li></ul>
</td></tr></table>
<h2><a name="Examples:"></a><span class="mw-headline"><font color="chocolate">Examples:</font></span></h2>
<ol>
<li>This example is used to browse an ASCII file and open it, then set the delimiter to comma, and then read the data into a worksheet with 8 rows and 12 columns.</li>
<pre class="lt" style="font-family:monospace;"><span style="color: #008000;">// start with standard worksheet</span>
for <span style="color: #000000;">&#40;</span>ii<span style="color: #000080;">=</span>wks.<span style="color: #000080;">ncols</span>;ii<span style="color: #000080;">&gt;</span><span style="color: #0000dd;">0</span>;ii<span style="color: #000080;">-</span><span style="color: #000080;">=</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
	del <span style="color: #000080;">%</span><span style="color: #000000;">&#40;</span><span style="color: #000080;">%</span>H,ii<span style="color: #000000;">&#41;</span>;	
<span style="color: #000000;">&#125;</span>;
wo <span style="color: #000080;">-</span>a <span style="color: #0000dd;">2</span>;
wks.<span style="color: #000080;">col1</span>.<span style="color: #000080;">type</span><span style="color: #000080;">=</span><span style="color: #0000dd;">4</span>;
doc <span style="color: #000080;">-</span>uw;

<span style="color: #008000;">// get ASCII file name in&#160;%A, path in&#160;%B</span>
getfile <span style="color: #000080;">*</span>.<span style="color: #000080;">dat</span>;
<span style="color: #008000;">// open the file, read-only</span>
hfile <span style="color: #000080;">=</span> file.<span style="color: #000080;">open</span><span style="color: #000000;">&#40;</span><span style="color: #000080;">%</span>B<span style="color: #000080;">%</span>A<span style="color: #000000;">&#41;</span>;
<span style="color: #008000;">// set delimiter to comma</span>
file.<span style="color: #000080;">listsep</span><span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;,&quot;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #008000;">// take 96 values of data and import into</span>
<span style="color: #008000;">// 8 rows of 12 columns each</span>
<span style="color: #008000;">// read the data</span>
loop <span style="color: #000000;">&#40;</span>row,<span style="color: #0000dd;">1</span>,<span style="color: #0000dd;">8</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
    tokensread <span style="color: #000080;">=</span> file.<span style="color: #000080;">readrow</span><span style="color: #000000;">&#40;</span><span style="color: #000080;">%</span>H,<span style="color: #0000dd;">12</span><span style="color: #000000;">&#41;</span>;
    type <span style="color: #000080;">-</span>q <span style="color: #ff00ff;">&quot;Importing Row $(row)&quot;</span>;
    if <span style="color: #000000;">&#40;</span>tokensread<span style="color: #000080;">&lt;=</span><span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span> break;
<span style="color: #000000;">&#125;</span>
file.<span style="color: #000080;">close</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
doc <span style="color: #000080;">-</span>uw;</pre>
<li>The following example is used to read data from a binary file, including some header information.</li>
<pre class="lt" style="font-family:monospace;"><span style="color: #008000;">// start with standard worksheet</span>
for <span style="color: #000000;">&#40;</span>ii<span style="color: #000080;">=</span>wks.<span style="color: #000080;">ncols</span>;ii<span style="color: #000080;">&gt;</span><span style="color: #0000dd;">0</span>;ii<span style="color: #000080;">-</span><span style="color: #000080;">=</span><span style="color: #0000dd;">1</span><span style="color: #000000;">&#41;</span> <span style="color: #000000;">&#123;</span>
	del <span style="color: #000080;">%</span><span style="color: #000000;">&#40;</span><span style="color: #000080;">%</span>H,ii<span style="color: #000000;">&#41;</span>;	
<span style="color: #000000;">&#125;</span>;
wo <span style="color: #000080;">-</span>a <span style="color: #0000dd;">2</span>;
wks.<span style="color: #000080;">col1</span>.<span style="color: #000080;">type</span><span style="color: #000080;">=</span><span style="color: #0000dd;">4</span>;
doc <span style="color: #000080;">-</span>uw;

<span style="color: #008000;">// get binary file name into&#160;%A, path into&#160;%B</span>
getfile <span style="color: #000080;">*</span>.<span style="color: #000080;">bin</span>;
hfile <span style="color: #000080;">=</span> file.<span style="color: #000080;">open</span><span style="color: #000000;">&#40;</span><span style="color: #000080;">%</span>B<span style="color: #000080;">%</span>A<span style="color: #000000;">&#41;</span>;

<span style="color: #008000;">// the first 8 header fields are 4 bytes each</span>
magic <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span>;
checksum <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span>;
start <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span>;
stop <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span>;
incr <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span>;
dwell <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span>;
drive <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span>;
numpts <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">4</span><span style="color: #000000;">&#41;</span>;
<span style="color: #008000;">// the next 4 header fields are 2 bytes each</span>
comments <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
evaluation <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
version <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
confidence <span style="color: #000080;">=</span> file.<span style="color: #000080;">read</span><span style="color: #000000;">&#40;</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;
<span style="color: #008000;">// read a string</span>
file.<span style="color: #000080;">cread</span><span style="color: #000000;">&#40;</span>A,<span style="color: #0000dd;">10</span><span style="color: #000000;">&#41;</span>;
<span style="color: #008000;">// set data size and sign</span>
file.<span style="color: #000080;">nbytes</span><span style="color: #000080;">=</span><span style="color: #0000dd;">2</span>;
file.<span style="color: #000080;">signed</span><span style="color: #000080;">=</span><span style="color: #0000dd;">1</span>;
<span style="color: #008000;">// read arrays of data of size 'numpts'</span>
file.<span style="color: #000080;">aread</span><span style="color: #000000;">&#40;</span><span style="color: #000080;">%</span>H_A,<span style="color: #0000dd;">1</span>,numpts,<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;
file.<span style="color: #000080;">aread</span><span style="color: #000000;">&#40;</span><span style="color: #000080;">%</span>H_B,<span style="color: #0000dd;">1</span>,numpts,<span style="color: #0000dd;">0</span><span style="color: #000000;">&#41;</span>;
<span style="color: #008000;">// display header information in the Script Window</span>
type <span style="color: #000080;">-</span>a;
magic <span style="color: #000080;">=</span>&#160;;
checksum <span style="color: #000080;">=</span>&#160;;
start <span style="color: #000080;">=</span>&#160;;
stop <span style="color: #000080;">=</span>&#160;;
incr <span style="color: #000080;">=</span>&#160;;
dwell <span style="color: #000080;">=</span>&#160;;
drive <span style="color: #000080;">=</span>&#160;;
numpts <span style="color: #000080;">=</span>&#160;;
comments <span style="color: #000080;">=</span>&#160;;
evaluation <span style="color: #000080;">=</span>&#160;;
version <span style="color: #000080;">=</span>&#160;;
confidence <span style="color: #000080;">=</span>&#160;;

file.<span style="color: #000080;">close</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
doc <span style="color: #000080;">-</span>uw;</pre>
<li>This example will show how to import an ASCII file into a worksheet.</li>
<pre class="lt" style="font-family:monospace;">newbook;  <span style="color: #008000;">// create a new workbook</span>
file.<span style="color: #000080;">filename</span><span style="color: #000080;">$</span> <span style="color: #000080;">=</span> system.<span style="color: #000080;">path</span>.<span style="color: #000080;">program</span><span style="color: #000080;">$</span> <span style="color: #000080;">+</span> <span style="color: #ff00ff;">&quot;Samples\Curve Fitting\Gamma.dat&quot;</span>;
file.<span style="color: #000080;">open</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;  <span style="color: #008000;">// open the file, read-only</span>
file.<span style="color: #000080;">listSep</span><span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;\t&quot;</span><span style="color: #000000;">&#41;</span>;  <span style="color: #008000;">// set delimiter to &quot;\t&quot;</span>
int nCurPos <span style="color: #000080;">=</span> file.<span style="color: #000080;">getPos</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;  <span style="color: #008000;">// get current position of file</span>
int nSize <span style="color: #000080;">=</span> file.<span style="color: #000080;">size</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;  <span style="color: #008000;">// get file size</span>
for<span style="color: #000000;">&#40;</span>; nCurPos <span style="color: #000080;">&lt;</span> nSize; <span style="color: #000000;">&#41;</span>  <span style="color: #008000;">// loop to read all data</span>
<span style="color: #000000;">&#123;</span>
	file.<span style="color: #000080;">readRow</span><span style="color: #000000;">&#40;</span><span style="color: #000080;">%</span>H, <span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;  <span style="color: #008000;">// read one row, with 2 data</span>
	nCurPos <span style="color: #000080;">=</span> file.<span style="color: #000080;">getPos</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;
<span style="color: #000000;">&#125;</span>
file.<span style="color: #000080;">close</span><span style="color: #000000;">&#40;</span><span style="color: #000000;">&#41;</span>;  <span style="color: #008000;">// close the file</span></pre>
</ol>






