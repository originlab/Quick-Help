<h1 class="firstHeading">18.8.2 Algorithms (Correlation)</h1><p class='urlname' style='display: none'>Corr1-Algorithm</p>
<h2><a name="Fast_algorithm_for_Correlation"></a><span class="mw-headline">Fast algorithm for Correlation</span></h2>
<p>Correlation is computed using a fast algorithm based on the correlation theorem.
</p><p>Let <i>f(n)</i> and <i>g(n)</i> be the input signals and <i>y(m)</i> denote the output, then we have:
</p><p><img src="../images/Algorithm_(Corr1)/math-cf1861c67e54acb5b00ddd00138e64b8.png?v=0" title=" y(m)=\sum_{n=0}^{M-1}f(n)g(n-m)=ifft(FG^{*})\,\!" alt=" y(m)=\sum_{n=0}^{M-1}f(n)g(n-m)=ifft(FG^{*})\,\!" class="tex"/>
</p><p>where <i>F</i> is the Fourier transform of <i>f(n)</i>, <i>G</i> is the Fourier transform of <i>g(n)</i> and * means complex conjugation. Therefore the computation of correlation is actually carried out as follows:
</p>
<ol><li>The discrete Fourier transforms of <i>f(n)</i> and <i>g(n)</i> are computed using FFT;</li>
<li>Multiply the Fourier coefficients of <i>f(n)</i> with the conjugated coefficients of <i>g(n)</i>;</li>
<li>Perform inverse discrete Fourier transform on the product.</li></ol>
<p>If the <b>Normalize</b> checkbox is selected, the two input signals are first normalized before the correlation is computed. 
</p><p>The normalization is as follows:
</p><p><img src="../images/Algorithm_(Corr1)/math-0f7a85db1250c0060b4a240f381b70ed.png?v=0" title=" f_{norm}(n)=\frac{f(n)}{\sqrt{\sum _{i=0}^{M-1}(f(n))^2}}\,\!" alt=" f_{norm}(n)=\frac{f(n)}{\sqrt{\sum _{i=0}^{M-1}(f(n))^2}}\,\!" class="tex"/> and <img src="../images/Algorithm_(Corr1)/math-d68e694bb0e18081ef32068839a362bb.png?v=0" title=" g_{norm}(n)=\frac{g(n)}{\sqrt{\sum_{i=0}^{M-1}(g(n))^2}} \,\!" alt=" g_{norm}(n)=\frac{g(n)}{\sqrt{\sum_{i=0}^{M-1}(g(n))^2}} \,\!" class="tex"/>
</p><p>The normalized correlation can be computed as:
</p><p><img src="../images/Algorithm_(Corr1)/math-252c4133aeac1e08706c4f3d5576a699.png?v=0" title=" y(m)=\sum_{i=0}^{M-1}f_{norm}(n)g_{norm}(n)=ifft(F_{norm}G_{norm}^{*}) \,\!" alt=" y(m)=\sum_{i=0}^{M-1}f_{norm}(n)g_{norm}(n)=ifft(F_{norm}G_{norm}^{*}) \,\!" class="tex"/>
</p><p>where <img src="../images/Algorithm_(Corr1)/math-2e057a1fbdaac5b5fdb1b62409b605ce.png?v=0" title="F_{norm}" alt="F_{norm}" class="tex"/> is the Fourier transform of <i>fnorm(n)</i>, <img src="../images/Algorithm_(Corr1)/math-9d26df42032d687e0505ffc3bde3335c.png?v=0" title="G_{norm}" alt="G_{norm}" class="tex"/> is the Fourier transform of <img src="../images/Algorithm_(Corr1)/math-5f16a89bc4cde292f9ac8d905fc73e6d.png?v=0" title="gnorm(n)" alt="gnorm(n)" class="tex"/> and * means complex conjugation.
</p><p>Note that if linear correlation is computed, zero padding will be performed before the computation of FFT.
</p>
<h2><a name="Automatic_Computation_of_Sampling_Interval"></a><span class="mw-headline">Automatic Computation of Sampling Interval</span></h2>
<p>When &lt;<b>Auto</b>&gt; is selected for <b>Sampling Interval</b>, the sampling interval needed in the computation is computed automatically by Origin. 
</p><p>The automatically computed sampling interval is the average increment of the time sequence, which is usually from the X column associated with the input signal. If there is no associated X column, the row numbers will be used. Note that if Origin fails to get the average increment, the sampling interval will be set to 1.
</p>





