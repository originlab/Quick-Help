<h1 class="firstHeading">18.5.2 Algorithms (Convolution)</h1><p class='urlname' style='display: none'>Conv-Algorithm</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Fast_algorithm_for_Convolution"><span class="tocnumber">1</span> <span class="toctext">Fast algorithm for Convolution</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Automatic_Computation_of_Sampling_Interval"><span class="tocnumber">2</span> <span class="toctext">Automatic Computation of Sampling Interval</span></a></li>
</ul>
</div>

<h2><a name="Fast_algorithm_for_Convolution"></a><span class="mw-headline">Fast algorithm for Convolution</span></h2>
<p>The algorithm for convolution in Origin in based on the convolution theorem. According to the theorem, convolving a signal with a response is the same as multiplying their Fourier transforms and then performing an inverse transform on the product. Thus: 
</p><p><img src="../images/Algorithm_(Conv)/math-0fa27f2163270df853dc9601fc152063.png?v=0" title=" f*g=ifft(fft(f)) \cdot fft(g)) \,\!" alt=" f*g=ifft(fft(f)) \cdot fft(g)) \,\!" class="tex"/>
</p><p>when the following assumptions are valid:
</p>
<ol><li>Both inputs (the signal and the response) are periodic;</li>
<li>The response has the same period as the signal.</li></ol>
<p>However, real data does not always meet these two requirements. Some zeroes must be padded to the inputs so that the algorithm based on convolution theorem can be applied. At the same time, care should be taken to ensure that the zero-padding and the assumption of periodicity does not cause artifacts in the results.
</p><p>For a circular convolution, data points outside the input range are considered to repeat periodically, thereby satisfying the first requirement. Zeros need to be padded to the end of input sequence (the signal or the response) with the shorter length to ensure that the lengths of both input sequences are equal.
</p><p>For a linear convolution, data points outside the input range are viewed as zeros. Assuming the signal to be periodic would cause artifacts in the result, because the wrapping adds some data from the far end to points in the beginning of the result. To avoid such artifacts, we must pad zeros to set up a buffer for the wrapped-around data. After padding, the lengths of both inputs should be 
</p><p><img src="../images/Algorithm_(Conv)/math-6452057b8299cfdc383437bb71c63eca.png?v=0" title="M_f+M_g-1 \,\!" alt="M_f+M_g-1 \,\!" class="tex"/>
</p><p>where <img src="../images/Algorithm_(Conv)/math-210ae0cf745771a69bd193a0e0227e06.png?v=0" title="M_f\,\!" alt="M_f\,\!" class="tex"/> and <img src="../images/Algorithm_(Conv)/math-89c54f97395a40ee1d71239b18ac815f.png?v=0" title="M_g\,\!" alt="M_g\,\!" class="tex"/> denotes the lengths of <i>f</i> and <i>g</i>. 
</p><p>After the padding, the fast convolution algorithm stated above is used to calculate the convolution result.
</p>
<h2><a name="Automatic_Computation_of_Sampling_Interval"></a><span class="mw-headline">Automatic Computation of Sampling Interval</span></h2>
<p>When &lt;<b>Auto</b>&gt; is selected for <b>Sampling Interval</b>, the sampling interval needed in the computation is computed automatically by Origin. 
</p><p>The automatically computed sampling interval is the average increment of the time sequence, which is usually from the X column associated with the input signal. If there is no associated X column, the row numbers will be used. Note that if Origin fails to get the average increment, the sampling interval will be set to 1.
</p>





