<h1 class="firstHeading">1.2.2 Operators</h1><p><span class="OIndex">Operators</span> support the same arithmetic, logical, comparative, and bitwise operators as ANSI C.  The following sections list the four types of operators and show their usage.
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Arithmetic_OperatorsRemainder"><span class="tocnumber">1</span> <span class="toctext"><span class="OIndex">Arithmetic Operators</span><span class="OIndex" style="display:none">Remainder</span></span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Comparison_Operators"><span class="tocnumber">2</span> <span class="toctext"><span class="OIndex">Comparison Operators</span></span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Logical_Operators"><span class="tocnumber">3</span> <span class="toctext"><span class="OIndex">Logical Operators</span></span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Bitwise_OperatorsAND_OperatorOR_OperatorXOR_Operator"><span class="tocnumber">4</span> <span class="toctext"><span class="OIndex">Bitwise Operators</span><span class="OIndex" style="display:none">AND Operator</span><span class="OIndex" style="display:none">OR Operator</span><span class="OIndex" style="display:none">XOR Operator</span></span></a></li>
</ul>
</div>

<h2><a name="Arithmetic_OperatorsRemainder"></a><span class="mw-headline"><span class="OIndex">Arithmetic Operators</span><span class="OIndex" style="display:none">Remainder</span></span></h2>
<table class="simple">
<tr>
<th> Operator
</th>
<th> Purpose
</th></tr>
<tr>
<td> <center>*</center>
</td>
<td> multiplication
</td></tr>
<tr>
<td> <center>/</center>
</td>
<td> division
</td></tr>
<tr>
<td> <center>%</center>
</td>
<td> modulus (remainder)
</td></tr>
<tr>
<td> <center>+</center>
</td>
<td> addition
</td></tr>
<tr>
<td> <center>-</center>
</td>
<td> subtraction
</td></tr>
<tr>
<td> <center>^</center>
</td>
<td> exponentiate<br />See note below.
</td></tr></table>
<p>Note: Origin C, by default, treats the caret character<span class="OIndex" style="display:none">Caret Character</span>(^) as an exponentiate operator<span class="OIndex" style="display:none">Exponentiate Operator</span>. This is done to be consistent with LabTalk. ANSI C uses the caret character as the exclusive OR operator. You can force Origin C to treat the caret character as the exclusive OR operator by using a special pragma statement before your code.
</p>
<pre class="oc" style="font-family:monospace;">out_int<span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;10 raised to the 3rd is &quot;</span>, <span style="color: #0000dd;">10</span><span style="color: #000040;">^</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">#pragma</span> xor<span style="color: #000000;">&#40;</span>push, <span style="color: #0000ff;">FALSE</span><span style="color: #000000;">&#41;</span>
out_int<span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;10 XOR 3 is &quot;</span>, <span style="color: #0000dd;">10</span><span style="color: #000040;">^</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">#pragma</span> xor<span style="color: #000000;">&#40;</span>pop<span style="color: #000000;">&#41;</span> <span style="color: #008000;">// set back to the default action of xor</span></pre>
<p>Dividing an integer by another integer will give an integer result by default. Use the pragma statement below before codes to make Origin C compiler to treat all numeric literals as double type.
</p>
<pre class="oc" style="font-family:monospace;">out_double<span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;3/2 is &quot;</span>, <span style="color: #0000dd;">3</span><span style="color: #000040;">/</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>; <span style="color: #008000;">// output 1</span>

<span style="color: #0000ff;">#pragma</span> numlittype<span style="color: #000000;">&#40;</span>push, <span style="color: #0000ff;">TRUE</span><span style="color: #000000;">&#41;</span>
out_double<span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;3/2 is &quot;</span>, <span style="color: #0000dd;">3</span><span style="color: #000040;">/</span><span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>; <span style="color: #008000;">// output 1.5</span>
<span style="color: #0000ff;">#pragma</span> numlittype<span style="color: #000000;">&#40;</span>pop<span style="color: #000000;">&#41;</span> <span style="color: #008000;">// set back to the default action of numlittype</span></pre>
<p>The modulus operator<span class="OIndex" style="display:none">Modulus Operator</span> calculates the remainder of the left operand divided by the right operand.  This operator can only be applied to integral operands.
</p>
<pre class="oc" style="font-family:monospace;">out_int<span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;The remainder of 11 divided by 2 is &quot;</span>, <span style="color: #0000dd;">11</span> <span style="color: #000040;">%</span> <span style="color: #0000dd;">2</span><span style="color: #000000;">&#41;</span>;</pre>
<h2><a name="Comparison_Operators"></a><span class="mw-headline"><span class="OIndex">Comparison Operators</span></span></h2>
<p>Comparison operators evaluate to true or false with true yielding 1 and false yielding 0.
</p>
<table class="simple">
<tr>
<th> Operator
</th>
<th> Purpose
</th></tr>
<tr>
<td> <center>&gt;</center>
</td>
<td> greater than
</td></tr>
<tr>
<td> <center>&gt;=</center>
</td>
<td> greater than or equal to
</td></tr>
<tr>
<td> <center>&lt;</center>
</td>
<td> less than
</td></tr>
<tr>
<td> <center>&lt;=</center>
</td>
<td> less than or equal to
</td></tr>
<tr>
<td> <center>==</center>
</td>
<td> equal to
</td></tr>
<tr>
<td> <center>!=</center>
</td>
<td> not equal to
</td></tr></table>
<p><br />
</p>
<pre class="oc" style="font-family:monospace;"><span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> aa <span style="color: #000080;">&gt;=</span> <span style="color: #0000dd;">0</span> <span style="color: #000000;">&#41;</span>
    out_str<span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;aa is greater than or equal to zero&quot;</span><span style="color: #000000;">&#41;</span>;

<span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> <span style="color: #0000dd;">12</span> <span style="color: #000080;">==</span> aa <span style="color: #000000;">&#41;</span>
    out_str<span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;aa is equal to twelve&quot;</span><span style="color: #000000;">&#41;</span>;
	
<span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> aa <span style="color: #000080;">&lt;</span> <span style="color: #0000dd;">99</span> <span style="color: #000000;">&#41;</span>
    out_str<span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;aa is less than 99&quot;</span><span style="color: #000000;">&#41;</span>;</pre>
<h2><a name="Logical_Operators"></a><span class="mw-headline"><span class="OIndex">Logical Operators</span></span></h2>
<p>Logical operators evaluate to true or false with true yielding 1 and false yielding 0.  The operands are evaluated from left to right.  Evaluation stops when the entire expression can be determined.
</p>
<table class="simple">
<tr>
<th> Operator
</th>
<th> Purpose
</th></tr>
<tr>
<td> <center>!</center>
</td>
<td> NOT
</td></tr>
<tr>
<td> <center>&amp;&amp;</center>
</td>
<td> AND
</td></tr>
<tr>
<td> <center>||</center>
</td>
<td> OR
</td></tr></table>
<p>Consider the following two examples:
</p>
<pre class="oc" style="font-family:monospace;">expr1A <span style="color: #000040;">&amp;&amp;</span> expr2
expr1B <span style="color: #000040;">||</span> expr2</pre>
<p>expr2 will not be evaluated if expr1A evaluates to false or expr1B evaluates to true.  This behavior is to the programmer's advantage and allows efficient code to be written.  The following demonstrates the importance of ordering more clearly.
</p>
<pre class="oc" style="font-family:monospace;"><span style="color: #0000ff;">if</span><span style="color: #000000;">&#40;</span> <span style="color: #0000ff;">NULL</span> <span style="color: #000040;">!</span><span style="color: #000080;">=</span> ptr <span style="color: #000040;">&amp;&amp;</span> ptr<span style="color: #000040;">-</span><span style="color: #000080;">&gt;</span>dataValue <span style="color: #000080;">&lt;</span> upperLimit <span style="color: #000000;">&#41;</span>
    process_data<span style="color: #000000;">&#40;</span>ptr<span style="color: #000000;">&#41;</span>;</pre>
<p>In the above example the entire 'if' expression will evaluate to false if ptr is equal to NULL.  If ptr is NULL then it is very important that the dataValue not be compared to the upperLimit because reading the dataValue member from a NULL pointer can cause an application to end abruptly.
</p>
<h2><a name="Bitwise_OperatorsAND_OperatorOR_OperatorXOR_Operator"></a><span class="mw-headline"><span class="OIndex">Bitwise Operators</span><span class="OIndex" style="display:none">AND Operator</span><span class="OIndex" style="display:none">OR Operator</span><span class="OIndex" style="display:none">XOR Operator</span></span></h2>
<p>Bitwise operators allow you to test and set individual bits.  The operator treats the operands as an ordered array of bits.  The operands of a bitwise operator must be of integral type.
</p>
<table class="simple">
<tr>
<th> Operator
</th>
<th> Purpose
</th></tr>
<tr>
<td> <center>~</center>
</td>
<td> complement
</td></tr>
<tr>
<td> <center>&lt;&lt;</center>
</td>
<td> shift left
</td></tr>
<tr>
<td> <center>&gt;&gt;</center>
</td>
<td> shift right
</td></tr>
<tr>
<td> <center>&amp;</center>
</td>
<td> AND
</td></tr>
<tr>
<td> <center>^</center>
</td>
<td> exclusive OR (XOR)<br />See note below.
</td></tr>
<tr>
<td> <center>|</center>
</td>
<td> inclusive (normal) OR
</td></tr></table>
<p>Note: Origin C, by default, treats the caret character as an exponentiate operator. This is done to be consistent with LabTalk. ANSI C uses the caret character as the exclusive OR operator. You can force Origin C to treat the caret character as the exclusive OR operator by using a special pragma statement before your code.
</p>
<pre class="oc" style="font-family:monospace;">out_int<span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;10 raised to the 3rd is &quot;</span>, <span style="color: #0000dd;">10</span><span style="color: #000040;">^</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">#pragma</span> xor<span style="color: #000000;">&#40;</span>push, <span style="color: #0000ff;">FALSE</span><span style="color: #000000;">&#41;</span>
out_int<span style="color: #000000;">&#40;</span><span style="color: #ff00ff;">&quot;10 XOR 3 is &quot;</span>, <span style="color: #0000dd;">10</span><span style="color: #000040;">^</span><span style="color: #0000dd;">3</span><span style="color: #000000;">&#41;</span>;
<span style="color: #0000ff;">#pragma</span> xor<span style="color: #000000;">&#40;</span>pop<span style="color: #000000;">&#41;</span></pre>






