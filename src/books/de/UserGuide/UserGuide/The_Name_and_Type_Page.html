<h1 class="firstHeading">Die Seite Name und Typ</h1>

  <p class='urlname' style='display: none'>FitFuncBuilder-NameType</p>

  <p>Auf der Seite Name und Typ können Sie die Kategorie, den Funktionsnamen, das Funktionsmodell und den Funktionstyp festlegen. Das linke Bedienfeld dieser Seite enthält Hinweise und Beispiele für jeden der Funktionstypen.</p>

  <h2><a name="Dialog_Box_Controls"></a><span class="mw-headline">Bedienelemente des Dialogs</span></h2>

  <table class="dialogcontroltable">
    <tr>
      <th>Eine Kategorie auswählen</th>

      <td>Wählen Sie eine vorhandene Kategorie aus, in der Sie neu erstellte Funktion ablegen. Dieses Bedienelement ist nicht verfügbar, wenn Sie die Option <b>Eine benutzerdefinierte Funktion bearbeiten</b> auf der Seite <b>Ziel</b> wählen. Um benutzerdefinierte Peakfunktionen und Basislinienfunktionen im Dialog <a href="../../UserGuide/UserGuide/Peak_Analyzer_Quick_Start.html" title="UserGuide:Peak Analyzer Quick Start">Peaks analysieren</a> zur Verfügung zu stellen, müssen Sie die Kategorie <b>PFW</b> für Peakfunktionen oder die Kategorie <b>Baseline</b> für Basislinienanpassungsfunktionen wählen. Oder Sie verwenden später <b>Hilfsmittel: Fitfunktionen verwalten</b> im Menü, um Ihre Funktion in der Kategorie PFW bzw. Baseline zu verschieben oder zu teilen.</td>
    </tr>

    <tr>
      <th>Neu</th>

      <td>Klicken Sie auf diese Schaltfläche <a class="image"><img alt="Ffb new category.png" src="../images/The_Name_and_Type_Page/Ffb_new_category.png" width="56"></a>, um einen Dialog aufzurufen, mit dem Sie eine neue Kategorie erstellen können. Dieses Bedienelement ist nicht verfügbar, wenn Sie die Option <b>Eine benutzerdefinierte Funktion bearbeiten</b> auf der Seite Ziel wählen.</td>
    </tr>

    <tr>
      <th>Funktionsname</th>

      <td>Geben Sie einen Namen für die Funktion ein. Dieses Bedienelement ist nicht verfügbar, wenn Sie die Option <b>Eine benutzerdefinierte Funktion bearbeiten</b> auf der Seite Ziel wählen.</td>
    </tr>

    <tr>
      <th>Dateiname (.FDF)</th>

      <td>Origin erstellt für jede hinzugefügte Funktion eine entsprechende .FDF-Datei, die im Ordner \FitFunc Ihres Anwenderdateiordners gespeichert wird. Dieses nur lesbare Bearbeitungsfeld zeigt den Namen der Anpassungsfunktionsdatei.</td>
    </tr>

    <tr>
      <th>Beschreibung</th>

      <td>Fügen Sie für die Funktion eine Beschreibung hinzu.</td>
    </tr>

    <tr>
      <th>Funktionsmodell</th>

      <td>
        Legen Sie das Funktionsmodell fest. Optionen:

        <ul>
          <li>
            <b>Explizit</b>

            <dl>
              <dd>Die Funktionformel kann explizit als y=f(x) definiert werden.</dd>
            </dl>
          </li>

          <li>
            <b>Implizit</b>

            <dl>
              <dd>Die Funktionsformel kann nicht explizit definiert werden, was mit f(x,y)=estimate ausgedrückt wird, wobei estimate 0 ist und in Origin mit f ausgedrückt wird.</dd>
            </dl>
          </li>
        </ul>
      </td>
    </tr>

    <tr>
      <th>Funktionstyp</th>

      <td>
        Legen Sie fest, wie die Funktion auf der Seite <b>Funktionskörper</b> definiert werden soll. Optionen:

        <ul>
          <li>
            <b>LabTalk-Ausdruck</b>

            <dl>
              <dd>
                Wählen Sie diese Option für einfache Anpassungsfunktionen, die nur über eine abhängige Variable verfügen. Der Funktionskörper ist auf einen Ausdruck beschränkt, und Sie müssen nur die rechte Seite der Gleichung eingeben. Diese Option bietet eine schnellere Leistung als Origin C. Das folgende Beispiel demonstriert diese Art von Funktionskörper.

                <dl>
                  <dd><i>a + b * exp( -x^c / d );</i></dd>
                </dl>
              </dd>
            </dl>
          </li>
        </ul>

        <ul>
          <li>
            <b>Python-Funktion (Skalar)</b>

            <dl>
              <dd>
                Skalarfunktionen erhalten einen Wert für jede unabhängige Variable während eines Abrufs und geben einen Wert für jede abhängige Variable aus. Diese Option ist langsamer als vektorbasiertes Anpassen und wird daher am besten für kleinere Datensätze verwendet. Aufgrund der Geschwindigkeit empfehlen wir das Verwenden von vektorialen Python-Anpassungsfunktionen. Das folgende Beispiel demonstriert diese Art von Funktionskörper. Beachten Sie, dass Sie dem Funktionsnamen das Präfix "py." voranstellen müssen, wenn Sie den Funktionskörper erstellen.

                <dl>
                  <dd><i>y = py.pyline(x, a, b);</i></dd>
                </dl>
              </dd>
            </dl>
          </li>
        </ul>

        <ul>
          <li>
            <b>Python-Funktion (Vektor)</b>

            <dl>
              <dd>
                Vektoriale Funktionen erhalten einen Array (in Form einer Liste) der unabhängigen Werte für jede unabhängige Variable während eines Abrufs und gibt einen Array (in Form einer Liste) für jede abhängige Variable aus. Aus diesem Grund ist es viel schneller als das Verwenden von skalaren Funktionen. Diese Option verwendet kein LabTalk-Verarbeitung. Das folgende Beispiel demonstriert diese Art von Funktionskörper.

                <dl>
                  <dd><i>y=pyGaussVectorEq(x,y0,xc,A,w);</i></dd>
                </dl>
              </dd>
            </dl>
          </li>
        </ul>

        <ul>
          <li>
            <b>LabTalk-Gleichungen</b>

            <dl>
              <dd>
                Wählen Sie diese Option, wenn Sie mehrere Zeilen brauchen oder Sie über mehr als eine abhängige Variable verfügen. Diese Option unterstützt Kontrollstrukturen wie Schleifen oder if-else-Anweisungen nicht. Sie können jedoch den ternären Operator verwenden. Diese Option bietet eine schnellere Leistung als Origin C. Das folgende Beispiel demonstriert diese Art von Funktionskörper.

                <dl>
                  <dd><i>temp = 10;</i></dd>

                  <dd><i>y1 = A + exp( (x1 - xc) / temp^2 );</i></dd>

                  <dd><i>y2 = A + temp / (x2 - xc)^2;</i></dd>
                </dl>
              </dd>
            </dl>
          </li>

          <li>
            <b>Origin C</b>

            <dl>
              <dd>
                Diese Option ist langsamer als <b>Gleichungen</b>. Wählen Sie diese Option, wenn Ihre Anpassungsfunktion Schleifen oder Kontrollstrukturen benötigt, die nicht von dem ternären Operator ersetzt werden können. Beachten Sie, dass Sie sich streng an die C-Syntax halten müssen: Bei Parametern muss die Groß- und Kleinschreibung beachtet werden, und die Division durch eine ganze Zahl unterscheidet sich von der Division durch ein "double". Das folgende Beispiel demonstriert diese Art von Funktionskörper.

                <dl>
                  <dd>
                    <i>if ( x &lt; -PI )</i>

                    <dl>
                      <dd><i>y = y0 + exp( -x-a*PI );</i></dd>
                    </dl>
                  </dd>

                  <dd>
                    <i>else if ( x &gt; PI )</i>

                    <dl>
                      <dd><i>y = y0 + exp( x-a*PI );</i></dd>
                    </dl>
                  </dd>

                  <dd>
                    <i>else</i>

                    <dl>
                      <dd><i>y = cos(x);</i></dd>
                    </dl>
                  </dd>
                </dl>
              </dd>
            </dl>
          </li>

          <li>
            <b>LabTalk-Skript</b>

            <dl>
              <dd>
                Diese Option ist viel langsamer als Gleichungen oder Origin C. Wählen Sie diese Option, wenn Sie Kontrollstrukturen brauchen oder nicht mit der C-Sprache vertraut sind. Das folgende Beispiel demonstriert diese Art von Funktionskörper.

                <dl>
                  <dd><i>range rr = %C;</i></dd>

                  <dd><i>int b = %(rr[P1]$);</i></dd>

                  <dd><i>y = b + a*x;</i></dd>
                </dl>
              </dd>
            </dl>
          </li>

          <li>
            <b>Externe DLL-basierte Funktion</b>

            <dl>
              <dd>Wählen Sie diese Option, um eine Anpassungsfunktion mit Hilfe einer externen DLL zu definieren. Mit einer externen DLL kann die Anpassungszeit signifikant verbessert werden. Weitere Einzelheiten zu diesem Typ finden Sie unter dem Thema <a href="../../UserGuide/UserGuide/Using_External_DLLs.html" title="UserGuide:Using External DLLs"><b>Externe DLL verwenden</b></a>.</dd>
            </dl>
          </li>
        </ul>

        <p><br>
        <b>Integration während Anpassung einschließen</b></p>

        <dl>
          <dd>Wählen Sie diese Option, um einen Integranden zu definieren und ihn in die Anpassungsfunktion einzubinden. Diese Option ist nur verfügbar, wenn <b>Funktionstyp</b> entweder <b>LabTalk-Ausdruck</b>, <b>LabTalk-Gleichungen</b> oder <b>LabTalk-Skript</b> ist. Das Funktionsmodell kann <b>explizit</b> oder <b>implizit</b> sein.</dd>
        </dl>
      </td>
    </tr>
  </table>
