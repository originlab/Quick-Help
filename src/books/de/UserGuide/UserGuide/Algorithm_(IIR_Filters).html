<h1 class="firstHeading">Algorithmus (IIR-Filter)</h1>

  <p>IIR-Filter (Infinite Impulse Response) sind digitale Filter mit Feedback, wie im folgenden Bild gezeigt.</p>

  <dl>
    <dd><img alt="Image:IIR_Filter_1.png" src="../images/Algorithm_(IIR_Filters)/IIR_Filter_1.png" width="650" height="297" border="0"></dd>
  </dl>

  <p>Digitale Filter werden auch häufig in Form einer Differenzgleichung beschrieben, die das Verhältnis zwischen Ausgabe- und Eingabesignal definiert.</p>

  <p><img class="tex" alt="b_0*x(n)+b_1*x(n-1)+ \cdots +b_N*x(n-N)-a_0*y(n)-a_1*y(n-1)- \cdots -a_M*y(n-M) = 0 " src="../images/math/9/d/b/9db6da2489a72297a61db6f8b02f39b9.png"></p>

  <p>Dann:</p>

  <p><img class="tex" alt="y(n) = \frac{1}{a_0} \left ( b_0*x(n)+b_1*x(n-1)+ \cdots +b_N*x(n-N)-a_1*y(n-1)-a_2*y(n-2)- \cdots -a_M*y(n-M) \right ) = \frac{1}{a_0} \left ( \sum_{i=0}^N b_i*x(n-i) - \sum_{j=1}^M a_j*y(n-j) \right )" src="../images/math/f/4/8/f48cc358b9ad6fc15d4184eecd703864.png"></p>

  <p>wobei <img class="tex" alt="a_0 \ne 0" src="../images/math/e/2/4/e24a6f3a97400170d57426ba23974f72.png">, N die vorgekoppelte Filterordnung, <span class="texhtml"><i>b</i><sub><i>i</i></sub></span> der vorgekoppelte Filterkoeffizient, M die rückgekoppelte Filterordnung, <span class="texhtml"><i>a</i><sub><i>i</i></sub></span> der rückgekoppelte Koeffizient, x(n) das Eingabesignal und y(n) das Ausgabesignal ist. Der Term <img class="tex" alt="\sum_{j=1}^M a_j*y(n-j)" src="../images/math/4/f/2/4f2ce3cca2e207c59db31efe2cac7d84.png"> ist die Rückkopplung.</p><a name="Digital_Filter_Representation"></a>

  <h2><span class="mw-headline">Darstellung von Digitalfiltern</span></h2>

  <p>In Origin gibt es vier Ausgaben für die Darstellung des IIR-Filters.</p>

  <ul>
    <li>Übertragungsfunktion</li>

    <li class="hcp1">
      <p>Die Übertragungsfunktion des IIR-Filters wird in der Z-Domäne durch das Verhältnis von zwei Polynomialen des Komplex <span class="texhtml"><i>z</i> <sup>- 1</sup></span> dargestellt. Um die Übertragungsfunktion des IIR-Filters zu suchen, ordnen Sie die obenstehende Gleichung folgendermaßen neu an:</p>

      <p><img class="tex" alt="\sum_{i=0}^N b_i*x(n-i) = \sum_{j=0}^M a_j*y(n-j)" src="../images/math/e/d/4/ed40bc7a57d62d8d81e458947a4ea12e.png"></p>

      <p>Die Z-Transformation wird dargestellt als:</p>

      <p><img class="tex" alt="X(z) = \sum_{}^{} x(n)z^n" src="../images/math/7/1/1/71196d29189ade0cee4a5c304c9bdcac.png"></p>

      <p>Nehmen Sie die Z-Transformation von jeder Seite der Filtergleichung. Sie erhalten:</p>

      <p><img class="tex" alt="\sum_{i=0}^N b_i*z^{-i}*X(z) = \sum_{j=0}^M a_j*z^{-j}*Y(z)" src="../images/math/a/b/c/abc88fc9b8ece15824cf1162bc65294c.png"></p>

      <p>Die Übertragungsfunktion des IIR-Filters in der Z-Domäne stellt Folgendes dar:</p>

      <p><img class="tex" alt="H(z) = \frac{Y(z)}{X(z)} = \frac{\sum_{i=0}^N b_iz^{-i}}{\sum_{j=0}^M a_jz^{-j}}" src="../images/math/f/5/7/f57840da50e29063036db64c4c64e2b5.png"></p>
    </li>

    <li>Nullstellen-Pole-Verstärkung</li>

    <li class="hcp1">
      <p>Wie bei der obenstehenden Übertragungsfunktion gezeigt, ist der Zähler für die Position der Nullstellen und der Nenner für die Pole bestimmt. Die Übertragungsfunktion kann dann in Form Nullstellen-Pole-Verstärkung neu geschrieben werden.</p>

      <p><img class="tex" alt="H(z) = \frac{q(z)}{p(z)} = k*\frac{(z-q_1)(z-q_2) \cdots (z-q_N)}{(z-p_1)(z-p_2) \cdots (z-p_M)} = k* \frac{\prod_{i=1}^N (z-q_i)}{\prod_{j=1}^M (z-p_j)}" src="../images/math/e/3/2/e323772fdba73070348db672b30b6bdd.png"></p>

      <p>wobei k die Verstärkung ist, <span class="texhtml"><i>q</i><sub><i>i</i></sub></span> und <span class="texhtml"><i>p</i><sub><i>j</i></sub></span> die Nullstellen bzw. die Pole der Übertragungsfunktion sind.</p>
    </li>

    <li>Zustand</li>

    <li class="hcp1">
      <p>Die Darstellung von Zustand-Raum für das Filtersystem kann definiert werden als:</p>

      <p><span class="texhtml"><i>x</i>(<i>n</i> + 1) = <i>A</i><i>x</i>(<i>n</i>) + <i>B</i><i>u</i>(<i>n</i>)</span></p>

      <p><span class="texhtml"><i>y</i>(<i>n</i>) = <i>C</i><i>x</i>(<i>n</i>) + <i>D</i><i>u</i>(<i>n</i>)</span></p>

      <p>wobei u(n) die Eingabe ist, x(n) der Zustandsvektor, y(n) die Ausgabe, A eine m x m-Matrix, m die Filterordnung, B ein Spaltenvektor, C der Zeilenvektor und D ein Skalar.</p>
    </li>

    <li>Kaskadierte IIR-Filter - Second Order Section (SOS)</li>

    <li class="hcp1">
      <p>Die äquivalente SOS-Darstellung der Übertragungsfunktion des Digitalfilters wird folgendermaßen geschrieben:</p>

      <p><img class="tex" alt="H(z) = g \prod_{k=1}^L H_k(z) = g \prod_{k=1}^L \frac{b_{0k}+b_{1k}*z^{-1}+b_{2k}*z^{-2}}{a_{0k}+a_{1k}*z^{-1}+a_{2k}*z^{-2}}" src="../images/math/b/f/2/bf2821b0551c54d131cbac9bfcc12926.png"></p>

      <p>wobei g die Verstärkung ist und <span class="texhtml"><i>b</i><sub>0<i>k</i></sub>,<i>b</i><sub>1<i>k</i></sub>,<i>b</i><sub>2<i>k</i></sub></span> die Zählerkoeffizienten sowie <span class="texhtml"><i>a</i><sub>0<i>k</i></sub>,<i>a</i><sub>1<i>k</i></sub>,<i>a</i><sub>2<i>k</i></sub></span> die Nennerkoeffizienten sind. Wenn die Filterordnung m gerade ist, <span class="texhtml"><i>L</i> = <i>m</i> / 2</span>, wenn m ungerade ist, <span class="texhtml"><i>L</i> = (<i>L</i> + 1) / 2</span>. SOS kann als folgende L-mal-6-Matrix dargestellt werden.</p>

      <p><img class="tex" alt="SOS =  \begin{bmatrix} b_{01} &amp; b_{11} &amp; b_{21} &amp; a_{01} &amp; a_{11} &amp; a_{21} \\ b_{02} &amp; b_{12} &amp; b_{22} &amp; a_{02} &amp; a_{12} &amp; a_{22} \\ b_{03} &amp; b_{13} &amp; b_{23} &amp; a_{03} &amp; a_{13} &amp; a_{23} \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\ b_{0L} &amp; b_{1L} &amp; b_{2L} &amp; a_{0L} &amp; a_{1L} &amp; a_{2L} \\ \end{bmatrix} " src="../images/math/6/8/f/68ff44eedfdf34c92d98f787bfb12b43.png"></p>
    </li>
  </ul><a name="How_to_Design_IIR_Filter"></a>

  <h2><span class="mw-headline">IIR-Filter entwerfen</span></h2>

  <p>Die gängige Vorgehensweise, um einen IIR-Filter zu entwerfen, ist:</p>

  <ol>
    <li>Filterspezifikation festlegen.</li>

    <li>Legen Sie den analogen Filterprototypen des Tiefpasses fest. Die verfügbaren Prototypen, die von Origin unterstützt werden, sind Butterworth, Tschebyscheff Typ I, Tschebyscheff Typ II und Elliptisch.</li>

    <li class="hcp1">
      <table class="simple">
        <tr>
          <th>Methode</th>

          <th>Quadrierte Betragsantwortfunktion</th>

          <th>Übertragungsfunktion von analogen Filtern</th>
        </tr>

        <tr>
          <td>Butterworth</td>

          <td><img class="tex" alt="|H_a(j \Omega)|^2 = \frac{1}{1+ \Omega^{2N}}" src="../images/math/b/d/6/bd6b0c0818a779f76cd445148a67e00f.png"></td>

          <td><img class="tex" alt="H_a(s) = \frac{q(s)}{p(s)} = \frac{g}{(s-p_1)(s-p_2)\cdots (s-p_N)} = \frac{g}{\prod_{k=1}^N (s-p_k)}" src="../images/math/a/2/d/a2d46654569c34032bc9057ac1194db0.png"></td>
        </tr>

        <tr>
          <td>Tschebyscheff Typ I</td>

          <td><img class="tex" alt="|H_a(j \Omega)|^2 = \frac{1}{1+ \varepsilon^2 T_N^2(\Omega)}" src="../images/math/2/2/0/2206c70efc0e120d06dc0b7e8db59f79.png"></td>

          <td><img class="tex" alt="H_a(s) = \frac{q(s)}{p(s)} = \frac{g}{(s-p_1)(s-p_2)\cdots (s-p_N)} = \frac{g}{\prod_{k=1}^N (s-p_k)}" src="../images/math/a/2/d/a2d46654569c34032bc9057ac1194db0.png"></td>
        </tr>

        <tr>
          <td>Tschebyscheff Typ II</td>

          <td><img class="tex" alt="|H_a(j \Omega)|^2 = \frac{1}{1+ (\varepsilon^2 T_N^2(\frac{1}{\Omega}))^{-1}} = \frac{\varepsilon^2 T_N^2(\frac{1}{\Omega})}{1+ \varepsilon^2 T_N^2(\frac{1}{\Omega})}" src="../images/math/d/2/6/d264d9b2d47dad93b4512e8158c94181.png"></td>

          <td><img class="tex" alt="H_a(s) = \frac{q(s)}{p(s)} = g \frac{(s-q_1)(s-q_2)\cdots (s-q_N)}{(s-p_1)(s-p_2)\cdots (s-p_N)} = g \prod_{k=1}^N \frac{(s-q_k)}{(s-p_k)}" src="../images/math/8/5/f/85fd70147d26a658710e337e81eb1c10.png"></td>
        </tr>

        <tr>
          <td>Elliptisch</td>

          <td><img class="tex" alt="|H_a(j \Omega)|^2 = \frac{1}{1+ \varepsilon^2 U_N^2(\Omega)}" src="../images/math/2/2/c/22c40847f51a917985f2519bede5aeb1.png"></td>

          <td><img class="tex" alt="H_a(s) = \frac{q(s)}{p(s)} = g \frac{(s-q_1)(s-q_2)\cdots (s-q_N)}{(s-p_1)(s-p_2)\cdots (s-p_N)} = g \frac{\prod_{i=1}^N (s-q_i)}{\prod_{j=1}^N (s-p_j)}" src="../images/math/8/8/1/88108f08f92bf9bfb7b2ab6d534d1b41.png"></td>
        </tr>
      </table>

      <p>In der obenstehenden Tabelle ist die Frequenz, N die Filterordnung, <img class="tex" alt="\varepsilon" src="../images/math/c/6/9/c691dc52cc1ad756972d4629934d37fd.png"> die maximale Oszillation in der Passbandfrequenzantwort, <span class="texhtml"><i>T</i><sub><i>N</i></sub></span> die Tschebyscheff-Polynomiale, <span class="texhtml"><i>U</i><sub><i>N</i></sub></span> die Jacobische elliptische Funktion, g die Skalar-Verstärkung, s die Ebene der Laplace-Transformation, <span class="texhtml"><i>q</i><sub><i>k</i></sub></span> oder <span class="texhtml"><i>q</i><sub><i>i</i></sub></span> die Nullstelle und <span class="texhtml"><i>p</i><sub><i>k</i></sub></span> oder <span class="texhtml"><i>p</i><sub><i>j</i></sub></span> die Pole.</p>
    </li>

    <li>Frequenztransformation für Analogfilter</li>

    <li class="hcp1">
      <p>Transformieren Sie den Tiefpassfilter in einen Hochpass-, Bandpass- oder Bandsperrfilter mit der gewünschten Abschneidefrequenz. In Origin wird die Form Zustand-Raum in der Berechnung der Frequenztransformation verwendet. Nehmen Sie an, dass die ursprüngliche Übertragungsfunktion des Tiefpassfilters <span class="texhtml"><i>H</i>(<i>s</i>')</span> ist und die Übertragungsfunktion nach der Transformation <span class="texhtml"><i>H</i>(<i>s</i>)</span>.</p>

      <ul>
        <li>Tiefpass in Tiefpass - Ein analoger Tiefpassfilter mit einer Abschneidefrequenz von 1 rad/s wird in einen Tiefpassfilter mit einer festgelegten Abschneidefrequenz transformiert.

          <dl>
            <dd><img class="tex" alt="H(s)= H(s')|_{s'=s/\omega_0}" src="../images/math/5/a/1/5a170c4cf851714490eec9720aff8d4b.png"></dd>
          </dl>
        </li>

        <li>Tiefpass in Hochpass

          <dl>
            <dd><img class="tex" alt="H(s) = H(s')|_{s'=\omega_0/s}" src="../images/math/3/7/8/37875c97c8f64c3dc04aaae1acd54d3f.png"></dd>
          </dl>
        </li>

        <li>Tiefpass in Bandpass

          <dl>
            <dd><img class="tex" alt="H(s) = H(s')|_{s'= \frac{\omega_0}{B_{\omega}} \frac{(s/\omega_0)^2+1}{s/\omega_0}}" src="../images/math/8/3/7/837227a1d8f99a82d0a20e0ac64798f0.png"></dd>
          </dl>
        </li>

        <li>Tiefpass in Bandsperre

          <dl>
            <dd><img class="tex" alt="H(s) = H(s')|_{s'= \frac{B_{\omega}}{\omega_0} \frac{s/\omega_0}{(s/\omega_0)^2+1}}" src="../images/math/5/7/3/57370d5aff345dacd8df9d2acfb85ecf.png"></dd>
          </dl>
        </li>
      </ul>

      <p>wobei <span class="texhtml"><sub>0</sub> = <i>s</i><i>q</i><i>r</i><i>t</i>(<sub>1</sub> * <sub>2</sub>)</span> die Mittenfrequenz ist, <span class="texhtml"><i>B</i> = <sub>2</sub> - <sub>1</sub></span> die Bandbreite sowie <span class="texhtml"><sub>1</sub></span> und <span class="texhtml"><sub>2</sub></span> die untere bzw. oberen Bandkante sind.</p>
    </li>

    <li>Konvertieren Sie einen Analogfilter in einen Digitalfilter.</li>

    <li class="hcp1">
      <p>Um einen Analogfilter in einen Digitalfilter zu konvertieren, verwendet Origin die bilineare Transformation, die durch folgenden Ausdruck definiert ist:</p>

      <p><img class="tex" alt="s = \frac{1-z^{-1}}{1+z^{-1}}" src="../images/math/e/a/c/eac09b4906107313ef469e6ab9df3ea1.png"></p>
    </li>
  </ol><a name="Forward_and_Backward_Filtering"></a>

  <h2><span class="mw-headline">Vorwärts- und Rückwärtsfilterung</span></h2>

  <p>Origin lässt die Durchführung von Vorwärts- und Rückwärtsfilterung zu, was zu einer Nullphasenverzerrung führt. Zuallererst wird die Filterung der Daten in Vorwärtsrichtung durchgeführt und dann die gefilterten Daten umgekehrt, um sie rückwärts durch den Filter laufen zu lassen.</p>

  <p>&#160;</p>
