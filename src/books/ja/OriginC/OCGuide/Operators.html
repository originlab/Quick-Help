<h1 class="firstheading">演算子</h1><p>演算子は、ANSI Cと同じ算術演算子、論理演算子、比較演算子、ビット演算子をサポートします。次のセクションは4種類の演算子とその用法を示します。 
</p>
<div id="toc" class="toc"><div id="toctitle"><h2>目次</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Arithmetic_OperatorsRemainder"><span class="tocnumber">1</span> <span class="toctext"><span class="OIndex">算術演算子</span><span class="OIndex" style="display:none">Remainder</span></span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Comparison_Operators"><span class="tocnumber">2</span> <span class="toctext"><span class="OIndex">比較演算子</span></span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Logical_Operators"><span class="tocnumber">3</span> <span class="toctext"><span class="OIndex">論理演算子</span></span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Bitwise_OperatorsAND_OperatorOR_OperatorXOR_Operator"><span class="tocnumber">4</span> <span class="toctext"><span class="OIndex">ビット演算子</span><span class="OIndex" style="display:none">AND Operator</span><span class="OIndex" style="display:none">OR Operator</span><span class="OIndex" style="display:none">XOR Operator</span></span></a></li>
</ul>
</div>

<h2><a name="Arithmetic_OperatorsRemainder"></a><span class="mw-headline"><span class="OIndex">算術演算子</span><span class="OIndex" style="display:none">Remainder</span></span></h2>
<table class="simple">
<tr>
<th> 演算子
</th>
<th> 目的
</th></tr>
<tr>
<td> <center>*</center>
</td>
<td> 乗算
</td></tr>
<tr>
<td> <center>/</center>
</td>
<td> 除算
</td></tr>
<tr>
<td> <center>%</center>
</td>
<td> 剰余（余り）
</td></tr>
<tr>
<td> <center>+</center>
</td>
<td> 加算
</td></tr>
<tr>
<td> <center>-</center>
</td>
<td> 減算
</td></tr>
<tr>
<td> <center>^</center>
</td>
<td> 指数<br />下記noteを参照
</td></tr></table>
<p>Note:デフォルトで、Origin Cは、指数演算子としてキャレット(^)を扱います。これはLabTalkと一貫性を持つために行われています。ANSI Cでは、キャレット(^)を排他論理和演算子(OR)として使います。コードの前に特別なpragmaステートメントを使って強制的にOrigin Cがキャレット(^)を排他論理和演算子（OR）として使うようにすることができます。 
</p>
<pre class="oc" style="font-family:monospace;">out_int<span style="color: #000000;">(</span><span style="color: #ff00ff;">&quot;10 raised to the 3rd is &quot;</span>, <span style="color: #0000dd;">10</span><span style="color: #000040;">^</span><span style="color: #0000dd;">3</span><span style="color: #000000;">)</span>;
<span style="color: #0000ff;">#pragma</span> xor<span style="color: #000000;">(</span>push, <span style="color: #0000ff;">FALSE</span><span style="color: #000000;">)</span>
out_int<span style="color: #000000;">(</span><span style="color: #ff00ff;">&quot;10 XOR 3 is &quot;</span>, <span style="color: #0000dd;">10</span><span style="color: #000040;">^</span><span style="color: #0000dd;">3</span><span style="color: #000000;">)</span>;
<span style="color: #0000ff;">#pragma</span> xor<span style="color: #000000;">(</span>pop<span style="color: #000000;">)</span> <span style="color: #008000;">// xorの動作をデフォルトに戻す</span></pre>
<p>整数を別の整数で除算すると整数の結果となります。  以下のpragmaステートメントをコード前に使用して、Origin Cコンパイラがすべての数値定数をdoubleとして扱うようにできます。
</p>
<pre class="oc" style="font-family:monospace;">out_double<span style="color: #000000;">(</span><span style="color: #ff00ff;">&quot;3/2 is &quot;</span>, <span style="color: #0000dd;">3</span><span style="color: #000040;">/</span><span style="color: #0000dd;">2</span><span style="color: #000000;">)</span>; <span style="color: #008000;">// 1が出力</span>

<span style="color: #0000ff;">#pragma</span> numlittype<span style="color: #000000;">(</span>push, <span style="color: #0000ff;">TRUE</span><span style="color: #000000;">)</span>
out_double<span style="color: #000000;">(</span><span style="color: #ff00ff;">&quot;3/2 is &quot;</span>, <span style="color: #0000dd;">3</span><span style="color: #000040;">/</span><span style="color: #0000dd;">2</span><span style="color: #000000;">)</span>; <span style="color: #008000;">// 1.5が出力</span>
<span style="color: #0000ff;">#pragma</span> numlittype<span style="color: #000000;">(</span>pop<span style="color: #000000;">)</span> <span style="color: #008000;">// numlittypeのデフォルトに戻す</span></pre>
<p>剰余演算子は、左オペランドを右オペランドで割った余りを計算します。  この演算子は整数のオペランドにのみ適用します。 
</p>
<pre class="oc" style="font-family:monospace;">out_int<span style="color: #000000;">(</span><span style="color: #ff00ff;">&quot;The remainder of 11 divided by 2 is &quot;</span>, <span style="color: #0000dd;">11</span> <span style="color: #000040;">%</span> <span style="color: #0000dd;">2</span><span style="color: #000000;">)</span>;</pre>
<h2><a name="Comparison_Operators"></a><span class="mw-headline"><span class="OIndex">比較演算子</span></span></h2>
<p>比較演算子は、TrueまたはFalseを評価し、Trueは1、Falseは0を返します。 
</p>
<table class="simple">
<tr>
<th> 演算子
</th>
<th> 目的
</th></tr>
<tr>
<td> <center>&gt;</center>
</td>
<td> より大きい
</td></tr>
<tr>
<td> <center>&gt;=</center>
</td>
<td> 以上
</td></tr>
<tr>
<td> <center>&lt;</center>
</td>
<td> より小さい
</td></tr>
<tr>
<td> <center>&lt;=</center>
</td>
<td> 以下
</td></tr>
<tr>
<td> <center>==</center>
</td>
<td> 等しい
</td></tr>
<tr>
<td> <center>!=</center>
</td>
<td> 等しくない
</td></tr></table>
<p><br />
</p>
<pre class="oc" style="font-family:monospace;"><span style="color: #0000ff;">if</span><span style="color: #000000;">(</span> aa <span style="color: #000080;">&gt;=</span> <span style="color: #0000dd;">0</span> <span style="color: #000000;">)</span>
    out_str<span style="color: #000000;">(</span><span style="color: #ff00ff;">&quot;aa is greater than or equal to zero&quot;</span><span style="color: #000000;">)</span>;

<span style="color: #0000ff;">if</span><span style="color: #000000;">(</span> <span style="color: #0000dd;">12</span> <span style="color: #000080;">==</span> aa <span style="color: #000000;">)</span>
    out_str<span style="color: #000000;">(</span><span style="color: #ff00ff;">&quot;aa is equal to twelve&quot;</span><span style="color: #000000;">)</span>;
	
<span style="color: #0000ff;">if</span><span style="color: #000000;">(</span> aa <span style="color: #000080;">&lt;</span> <span style="color: #0000dd;">99</span> <span style="color: #000000;">)</span>
    out_str<span style="color: #000000;">(</span><span style="color: #ff00ff;">&quot;aa is less than 99&quot;</span><span style="color: #000000;">)</span>;</pre>
<h2><a name="Logical_Operators"></a><span class="mw-headline"><span class="OIndex">論理演算子</span></span></h2>
<p>論理演算子は、TrueまたはFalseを評価し、Trueは1、Falseは0を返します。  オペランドは左から右へ評価されます。  論理式全体が決まったら評価が終わります。 
</p>
<table class="simple">
<tr>
<th> 演算子
</th>
<th> 目的
</th></tr>
<tr>
<td> <center>!</center>
</td>
<td> NOT
</td></tr>
<tr>
<td> <center>&amp;&amp;</center>
</td>
<td> AND
</td></tr>
<tr>
<td> <center>||</center>
</td>
<td> OR
</td></tr></table>
<p>次の2つのサンプルを考えます。
</p>
<pre class="oc" style="font-family:monospace;">expr1A <span style="color: #000040;">&amp;&amp;</span> expr2
expr1B <span style="color: #000040;">||</span> expr2</pre>
<p>expr1AがFalseまたはexpr1BがTrueとして評価されると、expr2は評価されません。  この動作は、プログラマにはメリットであり、効率的なコードを記述できます。  次は、順序の重要性を明確に表したものです。
</p>
<pre class="oc" style="font-family:monospace;"><span style="color: #0000ff;">if</span><span style="color: #000000;">(</span> <span style="color: #0000ff;">NULL</span> <span style="color: #000040;">!</span><span style="color: #000080;">=</span> ptr <span style="color: #000040;">&amp;&amp;</span> ptr<span style="color: #000040;">-</span><span style="color: #000080;">&gt;</span>dataValue <span style="color: #000080;">&lt;</span> upperLimit <span style="color: #000000;">)</span>
    process_data<span style="color: #000000;">(</span>ptr<span style="color: #000000;">)</span>;</pre>
<p>上記の例で、ptrがNULLに等しいと、if式全体はFalseに評価されます。  ptrがNULLの場合、NULLポインタからdataValueメンバーを読み取ると、アプリケーションが直ちに終了するので、dataValueがupperLimitと比較されないことが重要です。 
</p>
<h2><a name="Bitwise_OperatorsAND_OperatorOR_OperatorXOR_Operator"></a><span class="mw-headline"><span class="OIndex">ビット演算子</span><span class="OIndex" style="display:none">AND Operator</span><span class="OIndex" style="display:none">OR Operator</span><span class="OIndex" style="display:none">XOR Operator</span></span></h2>
<p>ビット演算子は個々のビットをテストし、設定します。  演算子は、オペランドをビットの配列として扱います。  ビット演算子のオペランドは不可欠なタイプでなければなりません。 
</p>
<table class="simple">
<tr>
<th> 演算子
</th>
<th> 目的
</th></tr>
<tr>
<td> <center>~</center>
</td>
<td> 補数
</td></tr>
<tr>
<td> <center>&lt;&lt;</center>
</td>
<td> 左にシフト
</td></tr>
<tr>
<td> <center>&gt;&gt;</center>
</td>
<td> 右にシフト
</td></tr>
<tr>
<td> <center>&amp;</center>
</td>
<td> AND
</td></tr>
<tr>
<td> <center>^</center>
</td>
<td> 排他論理和(XOR)<br />下記Noteを参照
</td></tr>
<tr>
<td> <center>|</center>
</td>
<td> 論理和 OR
</td></tr></table>
<p>Note:デフォルトで、Origin Cは、指数演算子としてキャレット(^)を扱います。これはLabTalkと一貫性を持つために行われています。ANSI Cでは、キャレット(^)を排他論理和演算子(OR)として使います。コードの前に特別なpragmaステートメントを使って強制的にOrigin Cがキャレット(^)を排他論理和演算子（OR）として使うようにすることができます。
</p>
<pre class="oc" style="font-family:monospace;">out_int<span style="color: #000000;">(</span><span style="color: #ff00ff;">&quot;10 raised to the 3rd is &quot;</span>, <span style="color: #0000dd;">10</span><span style="color: #000040;">^</span><span style="color: #0000dd;">3</span><span style="color: #000000;">)</span>;
<span style="color: #0000ff;">#pragma</span> xor<span style="color: #000000;">(</span>push, <span style="color: #0000ff;">FALSE</span><span style="color: #000000;">)</span>
out_int<span style="color: #000000;">(</span><span style="color: #ff00ff;">&quot;10 XOR 3 is &quot;</span>, <span style="color: #0000dd;">10</span><span style="color: #000040;">^</span><span style="color: #0000dd;">3</span><span style="color: #000000;">)</span>;
<span style="color: #0000ff;">#pragma</span> xor<span style="color: #000000;">(</span>pop<span style="color: #000000;">)</span></pre>







    